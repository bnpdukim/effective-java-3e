## 가능한 한 실패 원자적으로 만들라
* 실패 원자적(failure-atomic)
  - 호출된 메서드가 실패하더라도 해당 객체는 호출 전 상태를 유지해야 한다.
* 만드는 방법
  1. 불변 객체로 설계
  2. 매개변수의 유효성 검사
    ```
    public Object pop() {
      if(size == 0)
        throw new EmptyStackException();
      Object result = elements[--size];
      elements[size] = null;
      return result;
    }
    ```
    - 매개변수가 검사를 안했을 경우
      - size가 0일시 ArrayIndexOutOfBoundsException 발생
      - size가 음수가 되어 다음번 호출에서도 같은 예외 발생
      - ArrayIndexOutOfBoundsException 은 추상화 수준이 상황에 어울리지 않음
    - 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법
      - ex> TreeMap 에 적합하지 않은 원소 추가시 트리를 변경하기 전에 
        원소가 들어갈 위치를 찾는 과정에서 ClassCastException을 던짐
  3. 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 비교하는 것
    - ex> 리스트의 원소들을 배열로 옮긴후 정렬 진행
      - 정렬과정에서 문제가 생기더라도 입력 리스트는 변하지 않음
  4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법
    - 디스크 기반의 내구성을 보장해야 하는 자료구조
    - 자주 쓰이는 방법은 아님
* 실패 원자성은 항성 달성할 수 있는 것은 아니다.
  - 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 객체의 일관성이 깨질 수 있음.
    - ConcurrentModificationException을 잡아냈다고 해서 객체가 쓸 수 있는 상태라고 가정하면 안됨
  - Error는 복구할 수 없으므로 AssertionError에 대해서는 실패 원자적으로 만들려는 시도조차 할 필요가 없음
* 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 있으므로 항상 실패 원자적으로 만들어야 하는것은 아님
* 메서드 명세에 기술한 예외라면 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지되야 함
  - 잘 지켜지지 않는 부분  